const STR = 'string';
const NUM = 'number';

export type JavascriptRuntime = 'NODE' | 'WEB' | 'WEBWORKER';

/**
 * Initializes the PHP runtime with the given arguments and data dependencies.
 *
 * This function handles the entire PHP initialization pipeline. In particular, it:
 *
 * * Instantiates the Emscripten PHP module
 * * Wires it together with the data dependencies and loads them
 * * Ensures is all happens in a correct order
 * * Waits until the entire loading sequence is finished
 *
 * Basic usage:
 *
 * ```js
 *  const phpLoaderModule = await import("/php.js");
 *  const php = await startPHP(phpLoaderModule, "web");
 *  console.log(php.run(`<?php echo "Hello, world!"; `));
 *  // { stdout: ArrayBuffer containing the string "Hello, world!", stderr: [''], exitCode: 0 }
 * ```
 *
 * **The `/php.js` module:**
 *
 * In the basic usage example, `php.js` is **not** a vanilla Emscripten module. Instead,
 * it's an ESM module that wraps the regular Emscripten output and adds some
 * extra functionality. It's generated by the Dockerfile shipped with this repo.
 * Here's the API it provides:
 *
 * ```js
 * // php.wasm size in bytes:
 * export const dependenciesTotalSize = 5644199;
 *
 * // php.wasm filename:
 * export const dependencyFilename = 'php.wasm';
 *
 * // Run Emscripten's generated module:
 * export default function(jsEnv, emscriptenModuleArgs) {}
 * ```
 *
 * **PHP Filesystem:**
 *
 * Once initialized, the PHP has its own filesystem separate from the project
 * files. It's provided by [Emscripten and uses its FS library](https://emscripten.org/docs/api_reference/Filesystem-API.html).
 *
 * The API exposed to you via the PHP class is succinct and abstracts
 * await certain unintuitive parts of low-level FS interactions.
 *
 * Here's how to use it:
 *
 * ```js
 * // Recursively create a /var/www directory
 * php.mkdirTree('/var/www');
 *
 * console.log(php.fileExists('/var/www/file.txt'));
 * // false
 *
 * php.writeFile('/var/www/file.txt', 'Hello from the filesystem!');
 *
 * console.log(php.fileExists('/var/www/file.txt'));
 * // true
 *
 * console.log(php.readFile('/var/www/file.txt'));
 * // "Hello from the filesystem!
 *
 * // Delete the file:
 * php.unlink('/var/www/file.txt');
 * ```
 *
 * For more details consult the PHP class directly.
 *
 * **Data dependencies:**
 *
 * Using existing PHP packages by manually recreating them file-by-file would
 * be quite inconvenient. Fortunately, Emscripten provides a "data dependencies"
 * feature.
 *
 * Data dependencies consist of a `dependency.data` file and a `dependency.js` loader and
 * can be packaged with the [file_packager.py tool]( https://emscripten.org/docs/porting/files/packaging_files.html#packaging-using-the-file-packager-tool).
 * This project requires wrapping the Emscripten-generated `dependency.js` file in an ES
 * module as follows:
 *
 * 1. Prepend `export default function(emscriptenPHPModule) {'; `
 * 2. Prepend `export const dependencyFilename = '<DATA FILE NAME>'; `
 * 3. Prepend `export const dependenciesTotalSize = <DATA FILE SIZE>;`
 * 4. Append `}`
 *
 * Be sure to use the `--export-name="emscriptenPHPModule"` file_packager.py option.
 *
 * You want the final output to look as follows:
 *
 * ```js
 * export const dependenciesTotalSize = 5644199;
 * export const dependencyFilename = 'dependency.data';
 * export default function(emscriptenPHPModule) {
 *    // Emscripten-generated code:
 *    var Module = typeof emscriptenPHPModule !== 'undefined' ? emscriptenPHPModule : {};
 *    // ... the rest of it ...
 * }
 * ```
 *
 * Such a constructions enables loading the `dependency.js` as an ES Module using
 * `import("/dependency.js")`.
 *
 * Once it's ready, you can load PHP and your data dependencies as follows:
 *
 * ```js
 *  const [phpLoaderModule, wordPressLoaderModule] = await Promise.all([
 *    import("/php.js"),
 *    import("/wp.js")
 *  ]);
 *  const php = await startPHP(phpLoaderModule, "web", {}, [wordPressLoaderModule]);
 * ```
 *
 * @public
 * @param  phpLoaderModule         - The ESM-wrapped Emscripten module. Consult the Dockerfile for the build process.
 * @param  runtime                 - The current JavaScript environment. One of: NODE, WEB, or WEBWORKER.
 * @param  phpModuleArgs           - The Emscripten module arguments, see https://emscripten.org/docs/api_reference/module.html#affecting-execution.
 * @param  dataDependenciesModules - A list of the ESM-wrapped Emscripten data dependency modules.
 * @returns PHP instance.
 */
export async function startPHP(
	phpLoaderModule: any,
	runtime: JavascriptRuntime,
	phpModuleArgs: any = {},
	dataDependenciesModules: any[] = []
): Promise<PHP> {
	let resolvePhpReady, resolveDepsReady;
	const depsReady = new Promise((resolve) => {
		resolveDepsReady = resolve;
	});
	const phpReady = new Promise((resolve) => {
		resolvePhpReady = resolve;
	});

	const loadPHPRuntime = phpLoaderModule.default;
	const PHPRuntime = loadPHPRuntime(runtime, {
		onAbort(reason) {
			console.error('WASM aborted: ');
			console.error(reason);
		},
		...phpModuleArgs,
		noInitialRun: true,
		onRuntimeInitialized() {
			if (phpModuleArgs.onRuntimeInitialized) {
				phpModuleArgs.onRuntimeInitialized();
			}
			resolvePhpReady();
		},
		monitorRunDependencies(nbLeft) {
			if (nbLeft === 0) {
				delete PHPRuntime.monitorRunDependencies;
				resolveDepsReady();
			}
		},
	});
	for (const { default: loadDataModule } of dataDependenciesModules) {
		loadDataModule(PHPRuntime);
	}
	if (!dataDependenciesModules.length) {
		resolveDepsReady();
	}

	await depsReady;
	await phpReady;
	return new PHP(PHPRuntime);
}

/**
 * An environment-agnostic wrapper around the Emscripten PHP runtime
 * that abstracts the super low-level API and provides a more convenient
 * higher-level API.
 *
 * It exposes a minimal set of methods to run PHP scripts and to
 * interact with the PHP filesystem.
 *
 * @public
 * @see {startPHP} This class is not meant to be used directly. Use `startPHP` instead.
 */
export class PHP {
	#Runtime;

	/**
	 * Initializes a PHP runtime.
	 *
	 * @internal
	 * @param  PHPRuntime - PHP Runtime as initialized by startPHP.
	 */
	constructor(PHPRuntime: any) {
		this.#Runtime = PHPRuntime;

		this.mkdirTree('/usr/local/etc');
		// @TODO: make this customizable
		this.writeFile(
			'/usr/local/etc/php.ini',
			`[PHP]
error_reporting = E_ERROR | E_PARSE
display_errors = 1
html_errors = 1
display_startup_errors = On
session.save_path=/home/web_user
    `
		);
	}

	/**
	 * Runs a PHP script and outputs an object with three properties:
	 * stdout, stderr, and the exitCode.
	 *
	 * * `exitCode` – the exit code of the script. `0` is a success, while `1` and `2` indicate an error.
	 * * `stdout` – containing the output from `echo`, `print`, inline HTML etc.
	 * * `stderr` – containing all the errors are logged. It can also be written
	 *              to explicitly:
	 *
	 * ```js
	 * console.log(php.run(`<?php
	 *  $fp = fopen('php://stderr', 'w');
	 *  fwrite($fp, "Hello, world!");
	 * `));
	 * // {"exitCode":0,"stdout":"","stderr":["Hello, world!"]}
	 * ```
	 *
	 * @example
	 *
	 * ```js
	 * const output = php.run('<?php echo "Hello world!";');
	 * console.log(output.stdout); // "Hello world!"
	 * ```
	 *
	 * @param  code    - The PHP code to run.
	 * @param  options - The options object.
	 * @returns The PHP process output.
	 */
	run(code: string, options: PHPRequestOptions = {}): PHPOutput {
		options = {
			requestBody: '',
			...options,
		};

		const hasUploadedFiles = !!options.uploadedFiles?.filesQueryString;
		const additionalCode: string[] = [];
		if (hasUploadedFiles) {
			additionalCode.push(
				`<?php
				$request = (object) json_decode(<<<'REQUEST'
				${JSON.stringify({
					_FILES: options.uploadedFiles!.filesQueryString,
				})}
REQUEST
				, JSON_OBJECT_AS_ARRAY);
				parse_str($request->_FILES, $_FILES);
				?>`
			);
		}

		const exitCode = this.#Runtime.ccall(
			'phpwasm_run',
			NUM,
			[STR, STR, STR],
			[
				// char *php_code,
				`?><?php $_SERVER['PATH'] = '/'; ?>` +
					`${additionalCode.join('')}${code}`,

				// char *request_body,
				options.requestBody || '',

				// char *uploaded_files_paths
				hasUploadedFiles
					? options.uploadedFiles!.tmpPaths.join('\n')
					: '/tmp/test',
			]
		);

		// Remove the uploaded files
		if (hasUploadedFiles) {
			for (const uploadedFilePath of options.uploadedFiles!.tmpPaths) {
				if (this.fileExists(uploadedFilePath)) {
					this.unlink(uploadedFilePath);
				}
			}
		}

		return {
			exitCode,
			stdout: this.readFileAsBuffer('/tmp/stdout'),
			stderr: this.readFileAsText('/tmp/stderr').split('\n'),
		};
	}

	/**
	 * Prepares an object like { file1_name: File, ... } for
	 * being processed as $_FILES in PHP.
	 *
	 * In particular:
	 * * Creates the files in the filesystem
	 * * Allocates a global PHP rfc1867_uploaded_files HashTable
	 * * Registers the files in PHP's rfc1867_uploaded_files
	 * * Converts the JavaScript files object to the $_FILES data format like below
	 *
	 * Array(
	 *    [file1_name] => Array (
	 *       [name] => file_name.jpg
	 *       [type] => text/plain
	 *       [tmp_name] => /tmp/php/php1h4j1o (some path in the filesystem where the tmp file is kept for processing)
	 *       [error] => UPLOAD_ERR_OK  (= 0)
	 *       [size] => 123   (the size in bytes)
	 *    )
	 *    // ...
	 * )
	 *
	 * @param  files - JavaScript files keyed by their HTTP upload name.
	 * @returns $_FILES-compatible object.
	 */
	async uploadFiles(files: Record<string, File>): Promise<UploadedFiles> {
		const tmpPaths: string[] = [];
		const _FILES: Record<string, string> = {};
		for (const [key, value] of Object.entries(files)) {
			const tmpName = Math.random().toFixed(20);
			const tmpPath = `/tmp/${tmpName}`;
			// Need to read the blob and store it in the filesystem
			this.writeFile(tmpPath, new Uint8Array(await value.arrayBuffer()));
			_FILES[`${key}[name]`] = value.name;
			_FILES[`${key}[type]`] = value.type;
			_FILES[`${key}[tmp_name]`] = tmpPath;
			_FILES[`${key}[error]`] = '0';
			_FILES[`${key}[size]`] = value.size.toString();
			tmpPaths.push(tmpPath);
		}
		return {
			tmpPaths,
			filesQueryString: new URLSearchParams(_FILES).toString(),
		};
	}

	/**
	 * Recursively creates a directory with the given path in the PHP filesystem.
	 * For example, if the path is `/root/php/data`, and `/root` already exists,
	 * it will create the directories `/root/php` and `/root/php/data`.
	 *
	 * @param  path - The directory path to create.
	 */
	mkdirTree(path: string) {
		this.#Runtime.FS.mkdirTree(path);
	}

	/**
	 * Reads a file from the PHP filesystem and returns it as a string.
	 *
	 * @throws {@link ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to read.
	 * @returns The file contents.
	 */
	readFileAsText(path: string): string {
		return new TextDecoder().decode(this.readFileAsBuffer(path));
	}

	/**
	 * Reads a file from the PHP filesystem and returns it as an array buffer.
	 *
	 * @throws {@link ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to read.
	 * @returns The file contents.
	 */
	readFileAsBuffer(path: string): Uint8Array {
		return this.#Runtime.FS.readFile(path);
	}

	/**
	 * Overwrites data in a file in the PHP filesystem.
	 * Creates a new file if one doesn't exist yet.
	 *
	 * @param  path - The file path to write to.
	 * @param  data - The data to write to the file.
	 */
	writeFile(path: string, data: string | Uint8Array) {
		this.#Runtime.FS.writeFile(path, data);
	}

	/**
	 * Removes a file from the PHP filesystem.
	 *
	 * @throws {@link ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to remove.
	 */
	unlink(path: string) {
		this.#Runtime.FS.unlink(path);
	}

	/**
	 * Lists the files and directories in the given directory.
	 *
	 * @param  path - The directory path to list.
	 * @returns The list of files and directories in the given directory.
	 */
	listFiles(path: string): string[] {
		if (!this.fileExists(path)) {
			return [];
		}
		try {
			return this.#Runtime.FS.readdir(path).filter(
				(name) => name !== '.' && name !== '..'
			);
		} catch (e) {
			console.error(e, { path });
			return [];
		}
	}

	/**
	 * Checks if a directory exists in the PHP filesystem.
	 *
	 * @param  path – The path to check.
	 * @returns True if the path is a directory, false otherwise.
	 */
	isDir(path: string): boolean {
		if (!this.fileExists(path)) {
			return false;
		}
		return this.#Runtime.FS.isDir(
			this.#Runtime.FS.lookupPath(path).node.mode
		);
	}

	/**
	 * Checks if a file (or a directory) exists in the PHP filesystem.
	 *
	 * @param  path - The file path to check.
	 * @returns True if the file exists, false otherwise.
	 */
	fileExists(path: string): boolean {
		try {
			this.#Runtime.FS.lookupPath(path);
			return true;
		} catch (e) {
			return false;
		}
	}
}

export interface PHPRequestOptions {
	requestBody?: string;
	uploadedFiles?: UploadedFiles;
}

export interface UploadedFiles {
	tmpPaths: string[];
	filesQueryString: string;
}

/**
 * Output of the PHP.wasm runtime.
 */
export interface PHPOutput {
	/** Exit code of the PHP process. 0 means success, 1 and 2 mean error. */
	exitCode: number;

	/** Stdout data */
	stdout: ArrayBuffer;

	/** Stderr lines */
	stderr: string[];
}

/**
 * Emscripten's filesystem-related Exception.
 *
 * @see https://emscripten.org/docs/api_reference/Filesystem-API.html
 * @see https://github.com/emscripten-core/emscripten/blob/main/system/lib/libc/musl/arch/emscripten/bits/errno.h
 */
export interface ErrnoError extends Error {}
